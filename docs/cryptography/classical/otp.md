---
sidebar_position: 10
---

import OneTimePad from '@site/src/components/ciphers/OneTimePad';

# Одноразовый блокнот (Шифр Вернама)

**Одноразовый блокнот** (One-Time Pad, OTP) — единственный шифр с математически доказанной абсолютной стойкостью.

## История

- **1882** — Фрэнк Миллер описал концепцию
- **1917** — Гилберт Вернам запатентовал телеграфный шифратор
- **1949** — Клод Шеннон доказал абсолютную стойкость

## Принцип работы

Каждый символ открытого текста складывается с соответствующим символом ключа по модулю размера алфавита:

```
Cᵢ = (Pᵢ + Kᵢ) mod n

где:
  Pᵢ — символ открытого текста
  Kᵢ — символ ключа
  n  — размер алфавита
```

### Пример

```
Алфавит: А=0, Б=1, В=2, ... Я=32 (33 буквы)

Текст:   С  Е  К  Р  Е  Т     (18, 5, 10, 17, 5, 19)
Ключ:    К  Л  Ю  Ч  З  Д     (10, 11, 31, 23, 8, 4)
         ─────────────────────
Сумма:   28, 16, 41, 40, 13, 23
mod 33:  28, 16, 8,  7,  13, 23
         ─────────────────────
Шифр:    Ы  О  З  Ж  Н  Ч
```

## Интерактивный шифратор

<OneTimePad />

## Условия абсолютной стойкости

Для достижения абсолютной криптостойкости **все условия должны выполняться**:

| Условие | Требование |
|---------|------------|
| Длина ключа | ≥ длины сообщения |
| Случайность | Истинно случайный (не псевдослучайный) |
| Одноразовость | Каждый ключ используется только один раз |
| Секретность | Ключ известен только отправителю и получателю |

:::warning Критично!
Нарушение **любого** из условий полностью разрушает безопасность шифра.
:::

## Теорема Шеннона

> При выполнении всех условий, шифротекст не даёт никакой информации об открытом тексте, кроме его длины.

**Доказательство (упрощённо):**

Для любого шифротекста C и любого возможного открытого текста P существует ключ K, такой что:
```
C = P ⊕ K  →  K = C ⊕ P
```

Поэтому любой открытый текст равновероятен.

## Реализация на Python

```python
import secrets

def generate_key(length: int) -> bytes:
    """Генерация криптографически стойкого ключа"""
    return secrets.token_bytes(length)

def otp_encrypt(plaintext: bytes, key: bytes) -> bytes:
    """Шифрование одноразовым блокнотом"""
    if len(key) < len(plaintext):
        raise ValueError("Ключ короче открытого текста!")
    
    return bytes(p ^ k for p, k in zip(plaintext, key))

def otp_decrypt(ciphertext: bytes, key: bytes) -> bytes:
    """Дешифрование (идентично шифрованию)"""
    return otp_encrypt(ciphertext, key)

# Пример использования
message = "СЕКРЕТ".encode('utf-8')
key = generate_key(len(message))

ciphertext = otp_encrypt(message, key)
decrypted = otp_decrypt(ciphertext, key)

print(f"Сообщение: {message}")
print(f"Ключ (hex): {key.hex()}")
print(f"Шифротекст (hex): {ciphertext.hex()}")
print(f"Расшифровано: {decrypted.decode('utf-8')}")
```

## Атака при повторном использовании ключа

Если ключ K использован для двух сообщений P₁ и P₂:

```
C₁ = P₁ ⊕ K
C₂ = P₂ ⊕ K

C₁ ⊕ C₂ = P₁ ⊕ K ⊕ P₂ ⊕ K = P₁ ⊕ P₂
```

Получаем XOR двух открытых текстов — это позволяет применить криптоанализ!

### Пример атаки (crib dragging)

```python
def crib_drag(c1_xor_c2: bytes, crib: bytes):
    """Атака протаскиванием вероятного слова"""
    results = []
    for pos in range(len(c1_xor_c2) - len(crib) + 1):
        # XOR шифротекстов с предполагаемым словом
        candidate = bytes(
            c1_xor_c2[pos + i] ^ crib[i] 
            for i in range(len(crib))
        )
        # Проверяем, похоже ли на текст
        if all(32 <= b < 127 or b in [10, 13] for b in candidate):
            results.append((pos, candidate))
    return results
```

## Практические проблемы

| Проблема | Описание |
|----------|----------|
| Распределение ключей | Нужно безопасно передать ключ размером с сообщение |
| Хранение | Большие объёмы ключевого материала |
| Синхронизация | Отправитель и получатель должны быть синхронизированы |
| Генерация | Истинная случайность сложно достижима |

## Историческое использование

### Красная линия (Москва — Вашингтон)

Горячая линия между СССР и США использовала OTP с ключами на магнитных лентах.

### Числовые радиостанции

Шпионские радиостанции передавали зашифрованные числа, расшифровываемые агентами с одноразовыми блокнотами.

### Проект VENONA

США смогли расшифровать советские сообщения 1940-х годов, когда обнаружили повторное использование ключей.

## Современные альтернативы

| Метод | Преимущество |
|-------|--------------|
| AES-256 | Короткий ключ, высокая скорость |
| ChaCha20 | Быстрый потоковый шифр |
| Квантовое распределение | Безопасная передача ключей |

:::info Когда использовать OTP?
В современной практике OTP используется редко из-за проблем с ключами. Однако он остаётся эталоном для оценки криптографической стойкости.
:::
